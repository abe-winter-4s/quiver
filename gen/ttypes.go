// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package gen

import (
	"bytes"
	"fmt"

	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var GoUnusedProtection__ int

type HFileServiceAction int64

const (
	HFileServiceAction_fetchValuesSingle       HFileServiceAction = 0
	HFileServiceAction_fetchValuesMulti        HFileServiceAction = 1
	HFileServiceAction_getIterator             HFileServiceAction = 2
	HFileServiceAction_fetchValuesForPrefixes  HFileServiceAction = 3
	HFileServiceAction_fetchValuesForSplitKeys HFileServiceAction = 4
)

func (p HFileServiceAction) String() string {
	switch p {
	case HFileServiceAction_fetchValuesSingle:
		return "HFileServiceAction_fetchValuesSingle"
	case HFileServiceAction_fetchValuesMulti:
		return "HFileServiceAction_fetchValuesMulti"
	case HFileServiceAction_getIterator:
		return "HFileServiceAction_getIterator"
	case HFileServiceAction_fetchValuesForPrefixes:
		return "HFileServiceAction_fetchValuesForPrefixes"
	case HFileServiceAction_fetchValuesForSplitKeys:
		return "HFileServiceAction_fetchValuesForSplitKeys"
	}
	return "<UNSET>"
}

func HFileServiceActionFromString(s string) (HFileServiceAction, error) {
	switch s {
	case "HFileServiceAction_fetchValuesSingle":
		return HFileServiceAction_fetchValuesSingle, nil
	case "HFileServiceAction_fetchValuesMulti":
		return HFileServiceAction_fetchValuesMulti, nil
	case "HFileServiceAction_getIterator":
		return HFileServiceAction_getIterator, nil
	case "HFileServiceAction_fetchValuesForPrefixes":
		return HFileServiceAction_fetchValuesForPrefixes, nil
	case "HFileServiceAction_fetchValuesForSplitKeys":
		return HFileServiceAction_fetchValuesForSplitKeys, nil
	}
	return HFileServiceAction(0), fmt.Errorf("not a valid HFileServiceAction string")
}

func HFileServiceActionPtr(v HFileServiceAction) *HFileServiceAction { return &v }

type HFileServiceException struct {
	Message *string `thrift:"message,1" json:"message"`
}

func NewHFileServiceException() *HFileServiceException {
	return &HFileServiceException{}
}

var HFileServiceException_Message_DEFAULT string

func (p *HFileServiceException) GetMessage() string {
	if !p.IsSetMessage() {
		return HFileServiceException_Message_DEFAULT
	}
	return *p.Message
}
func (p *HFileServiceException) IsSetMessage() bool {
	return p.Message != nil
}

func (p *HFileServiceException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *HFileServiceException) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Message = &v
	}
	return nil
}

func (p *HFileServiceException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("HFileServiceException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *HFileServiceException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetMessage() {
		if err := oprot.WriteFieldBegin("message", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:message: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Message)); err != nil {
			return fmt.Errorf("%T.message (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:message: %s", p, err)
		}
	}
	return err
}

func (p *HFileServiceException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("HFileServiceException(%+v)", *p)
}

func (p *HFileServiceException) Error() string {
	return p.String()
}

type SingleHFileKeyRequest struct {
	HfileName        *string  `thrift:"hfileName,1" json:"hfileName"`
	SortedKeys       [][]byte `thrift:"sortedKeys,2" json:"sortedKeys"`
	PerKeyValueLimit *int32   `thrift:"perKeyValueLimit,3" json:"perKeyValueLimit"`
	CountOnly        *bool    `thrift:"countOnly,4" json:"countOnly"`
}

func NewSingleHFileKeyRequest() *SingleHFileKeyRequest {
	return &SingleHFileKeyRequest{}
}

var SingleHFileKeyRequest_HfileName_DEFAULT string

func (p *SingleHFileKeyRequest) GetHfileName() string {
	if !p.IsSetHfileName() {
		return SingleHFileKeyRequest_HfileName_DEFAULT
	}
	return *p.HfileName
}

var SingleHFileKeyRequest_SortedKeys_DEFAULT [][]byte

func (p *SingleHFileKeyRequest) GetSortedKeys() [][]byte {
	return p.SortedKeys
}

var SingleHFileKeyRequest_PerKeyValueLimit_DEFAULT int32

func (p *SingleHFileKeyRequest) GetPerKeyValueLimit() int32 {
	if !p.IsSetPerKeyValueLimit() {
		return SingleHFileKeyRequest_PerKeyValueLimit_DEFAULT
	}
	return *p.PerKeyValueLimit
}

var SingleHFileKeyRequest_CountOnly_DEFAULT bool

func (p *SingleHFileKeyRequest) GetCountOnly() bool {
	if !p.IsSetCountOnly() {
		return SingleHFileKeyRequest_CountOnly_DEFAULT
	}
	return *p.CountOnly
}
func (p *SingleHFileKeyRequest) IsSetHfileName() bool {
	return p.HfileName != nil
}

func (p *SingleHFileKeyRequest) IsSetSortedKeys() bool {
	return p.SortedKeys != nil
}

func (p *SingleHFileKeyRequest) IsSetPerKeyValueLimit() bool {
	return p.PerKeyValueLimit != nil
}

func (p *SingleHFileKeyRequest) IsSetCountOnly() bool {
	return p.CountOnly != nil
}

func (p *SingleHFileKeyRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SingleHFileKeyRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.HfileName = &v
	}
	return nil
}

func (p *SingleHFileKeyRequest) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SortedKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem0 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem0 = v
		}
		p.SortedKeys = append(p.SortedKeys, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *SingleHFileKeyRequest) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.PerKeyValueLimit = &v
	}
	return nil
}

func (p *SingleHFileKeyRequest) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.CountOnly = &v
	}
	return nil
}

func (p *SingleHFileKeyRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SingleHFileKeyRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SingleHFileKeyRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetHfileName() {
		if err := oprot.WriteFieldBegin("hfileName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:hfileName: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.HfileName)); err != nil {
			return fmt.Errorf("%T.hfileName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:hfileName: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSortedKeys() {
		if err := oprot.WriteFieldBegin("sortedKeys", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sortedKeys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.SortedKeys)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.SortedKeys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sortedKeys: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetPerKeyValueLimit() {
		if err := oprot.WriteFieldBegin("perKeyValueLimit", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:perKeyValueLimit: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.PerKeyValueLimit)); err != nil {
			return fmt.Errorf("%T.perKeyValueLimit (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:perKeyValueLimit: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetCountOnly() {
		if err := oprot.WriteFieldBegin("countOnly", thrift.BOOL, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:countOnly: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.CountOnly)); err != nil {
			return fmt.Errorf("%T.countOnly (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:countOnly: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SingleHFileKeyRequest(%+v)", *p)
}

type SingleHFileKeyResponse struct {
	Values   map[int32][]byte `thrift:"values,1" json:"values"`
	KeyCount *int32           `thrift:"keyCount,2" json:"keyCount"`
}

func NewSingleHFileKeyResponse() *SingleHFileKeyResponse {
	return &SingleHFileKeyResponse{}
}

var SingleHFileKeyResponse_Values_DEFAULT map[int32][]byte

func (p *SingleHFileKeyResponse) GetValues() map[int32][]byte {
	return p.Values
}

var SingleHFileKeyResponse_KeyCount_DEFAULT int32

func (p *SingleHFileKeyResponse) GetKeyCount() int32 {
	if !p.IsSetKeyCount() {
		return SingleHFileKeyResponse_KeyCount_DEFAULT
	}
	return *p.KeyCount
}
func (p *SingleHFileKeyResponse) IsSetValues() bool {
	return p.Values != nil
}

func (p *SingleHFileKeyResponse) IsSetKeyCount() bool {
	return p.KeyCount != nil
}

func (p *SingleHFileKeyResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SingleHFileKeyResponse) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int32][]byte, size)
	p.Values = tMap
	for i := 0; i < size; i++ {
		var _key1 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key1 = v
		}
		var _val2 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val2 = v
		}
		p.Values[_key1] = _val2
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *SingleHFileKeyResponse) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.KeyCount = &v
	}
	return nil
}

func (p *SingleHFileKeyResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SingleHFileKeyResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *SingleHFileKeyResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetValues() {
		if err := oprot.WriteFieldBegin("values", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:values: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.I32, thrift.STRING, len(p.Values)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Values {
			if err := oprot.WriteI32(int32(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:values: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyResponse) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCount() {
		if err := oprot.WriteFieldBegin("keyCount", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:keyCount: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.KeyCount)); err != nil {
			return fmt.Errorf("%T.keyCount (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:keyCount: %s", p, err)
		}
	}
	return err
}

func (p *SingleHFileKeyResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SingleHFileKeyResponse(%+v)", *p)
}

type MultiHFileKeyResponse struct {
	Values   map[int32][][]byte `thrift:"values,1" json:"values"`
	KeyCount *int32             `thrift:"keyCount,2" json:"keyCount"`
}

func NewMultiHFileKeyResponse() *MultiHFileKeyResponse {
	return &MultiHFileKeyResponse{}
}

var MultiHFileKeyResponse_Values_DEFAULT map[int32][][]byte

func (p *MultiHFileKeyResponse) GetValues() map[int32][][]byte {
	return p.Values
}

var MultiHFileKeyResponse_KeyCount_DEFAULT int32

func (p *MultiHFileKeyResponse) GetKeyCount() int32 {
	if !p.IsSetKeyCount() {
		return MultiHFileKeyResponse_KeyCount_DEFAULT
	}
	return *p.KeyCount
}
func (p *MultiHFileKeyResponse) IsSetValues() bool {
	return p.Values != nil
}

func (p *MultiHFileKeyResponse) IsSetKeyCount() bool {
	return p.KeyCount != nil
}

func (p *MultiHFileKeyResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultiHFileKeyResponse) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int32][][]byte, size)
	p.Values = tMap
	for i := 0; i < size; i++ {
		var _key3 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key3 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([][]byte, 0, size)
		_val4 := tSlice
		for i := 0; i < size; i++ {
			var _elem5 []byte
			if v, err := iprot.ReadBinary(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem5 = v
			}
			_val4 = append(_val4, _elem5)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Values[_key3] = _val4
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MultiHFileKeyResponse) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.KeyCount = &v
	}
	return nil
}

func (p *MultiHFileKeyResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MultiHFileKeyResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultiHFileKeyResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetValues() {
		if err := oprot.WriteFieldBegin("values", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:values: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.I32, thrift.LIST, len(p.Values)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Values {
			if err := oprot.WriteI32(int32(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:values: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileKeyResponse) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCount() {
		if err := oprot.WriteFieldBegin("keyCount", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:keyCount: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.KeyCount)); err != nil {
			return fmt.Errorf("%T.keyCount (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:keyCount: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileKeyResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultiHFileKeyResponse(%+v)", *p)
}

type PrefixRequest struct {
	HfileName  *string  `thrift:"hfileName,1" json:"hfileName"`
	SortedKeys [][]byte `thrift:"sortedKeys,2" json:"sortedKeys"`
}

func NewPrefixRequest() *PrefixRequest {
	return &PrefixRequest{}
}

var PrefixRequest_HfileName_DEFAULT string

func (p *PrefixRequest) GetHfileName() string {
	if !p.IsSetHfileName() {
		return PrefixRequest_HfileName_DEFAULT
	}
	return *p.HfileName
}

var PrefixRequest_SortedKeys_DEFAULT [][]byte

func (p *PrefixRequest) GetSortedKeys() [][]byte {
	return p.SortedKeys
}
func (p *PrefixRequest) IsSetHfileName() bool {
	return p.HfileName != nil
}

func (p *PrefixRequest) IsSetSortedKeys() bool {
	return p.SortedKeys != nil
}

func (p *PrefixRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrefixRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.HfileName = &v
	}
	return nil
}

func (p *PrefixRequest) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.SortedKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem6 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem6 = v
		}
		p.SortedKeys = append(p.SortedKeys, _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *PrefixRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("PrefixRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrefixRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetHfileName() {
		if err := oprot.WriteFieldBegin("hfileName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:hfileName: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.HfileName)); err != nil {
			return fmt.Errorf("%T.hfileName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:hfileName: %s", p, err)
		}
	}
	return err
}

func (p *PrefixRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSortedKeys() {
		if err := oprot.WriteFieldBegin("sortedKeys", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sortedKeys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.SortedKeys)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.SortedKeys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sortedKeys: %s", p, err)
		}
	}
	return err
}

func (p *PrefixRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrefixRequest(%+v)", *p)
}

type PrefixResponse struct {
	Values map[string][][]byte `thrift:"values,1" json:"values"`
}

func NewPrefixResponse() *PrefixResponse {
	return &PrefixResponse{}
}

var PrefixResponse_Values_DEFAULT map[string][][]byte

func (p *PrefixResponse) GetValues() map[string][][]byte {
	return p.Values
}
func (p *PrefixResponse) IsSetValues() bool {
	return p.Values != nil
}

func (p *PrefixResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrefixResponse) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][][]byte, size)
	p.Values = tMap
	for i := 0; i < size; i++ {
		var _key7 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key7 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([][]byte, 0, size)
		_val8 := tSlice
		for i := 0; i < size; i++ {
			var _elem9 []byte
			if v, err := iprot.ReadBinary(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem9 = v
			}
			_val8 = append(_val8, _elem9)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Values[_key7] = _val8
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *PrefixResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("PrefixResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PrefixResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetValues() {
		if err := oprot.WriteFieldBegin("values", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:values: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Values)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Values {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:values: %s", p, err)
		}
	}
	return err
}

func (p *PrefixResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrefixResponse(%+v)", *p)
}

type MultiHFileSplitKeyRequest struct {
	HfileName             *string    `thrift:"hfileName,1" json:"hfileName"`
	RetiredSortedPrefixes [][]byte   `thrift:"retired_sortedPrefixes,2" json:"retired_sortedPrefixes"`
	RetiredSortedSuffixes [][]byte   `thrift:"retired_sortedSuffixes,3" json:"retired_sortedSuffixes"`
	SplitKey              [][][]byte `thrift:"splitKey,4" json:"splitKey"`
}

func NewMultiHFileSplitKeyRequest() *MultiHFileSplitKeyRequest {
	return &MultiHFileSplitKeyRequest{}
}

var MultiHFileSplitKeyRequest_HfileName_DEFAULT string

func (p *MultiHFileSplitKeyRequest) GetHfileName() string {
	if !p.IsSetHfileName() {
		return MultiHFileSplitKeyRequest_HfileName_DEFAULT
	}
	return *p.HfileName
}

var MultiHFileSplitKeyRequest_RetiredSortedPrefixes_DEFAULT [][]byte

func (p *MultiHFileSplitKeyRequest) GetRetiredSortedPrefixes() [][]byte {
	return p.RetiredSortedPrefixes
}

var MultiHFileSplitKeyRequest_RetiredSortedSuffixes_DEFAULT [][]byte

func (p *MultiHFileSplitKeyRequest) GetRetiredSortedSuffixes() [][]byte {
	return p.RetiredSortedSuffixes
}

var MultiHFileSplitKeyRequest_SplitKey_DEFAULT [][][]byte

func (p *MultiHFileSplitKeyRequest) GetSplitKey() [][][]byte {
	return p.SplitKey
}
func (p *MultiHFileSplitKeyRequest) IsSetHfileName() bool {
	return p.HfileName != nil
}

func (p *MultiHFileSplitKeyRequest) IsSetRetiredSortedPrefixes() bool {
	return p.RetiredSortedPrefixes != nil
}

func (p *MultiHFileSplitKeyRequest) IsSetRetiredSortedSuffixes() bool {
	return p.RetiredSortedSuffixes != nil
}

func (p *MultiHFileSplitKeyRequest) IsSetSplitKey() bool {
	return p.SplitKey != nil
}

func (p *MultiHFileSplitKeyRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.HfileName = &v
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.RetiredSortedPrefixes = tSlice
	for i := 0; i < size; i++ {
		var _elem10 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem10 = v
		}
		p.RetiredSortedPrefixes = append(p.RetiredSortedPrefixes, _elem10)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.RetiredSortedSuffixes = tSlice
	for i := 0; i < size; i++ {
		var _elem11 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem11 = v
		}
		p.RetiredSortedSuffixes = append(p.RetiredSortedSuffixes, _elem11)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][][]byte, 0, size)
	p.SplitKey = tSlice
	for i := 0; i < size; i++ {
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([][]byte, 0, size)
		_elem12 := tSlice
		for i := 0; i < size; i++ {
			var _elem13 []byte
			if v, err := iprot.ReadBinary(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem13 = v
			}
			_elem12 = append(_elem12, _elem13)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.SplitKey = append(p.SplitKey, _elem12)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("MultiHFileSplitKeyRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MultiHFileSplitKeyRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetHfileName() {
		if err := oprot.WriteFieldBegin("hfileName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:hfileName: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.HfileName)); err != nil {
			return fmt.Errorf("%T.hfileName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:hfileName: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileSplitKeyRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetRetiredSortedPrefixes() {
		if err := oprot.WriteFieldBegin("retired_sortedPrefixes", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:retired_sortedPrefixes: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.RetiredSortedPrefixes)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.RetiredSortedPrefixes {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:retired_sortedPrefixes: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileSplitKeyRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRetiredSortedSuffixes() {
		if err := oprot.WriteFieldBegin("retired_sortedSuffixes", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:retired_sortedSuffixes: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.RetiredSortedSuffixes)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.RetiredSortedSuffixes {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:retired_sortedSuffixes: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileSplitKeyRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSplitKey() {
		if err := oprot.WriteFieldBegin("splitKey", thrift.LIST, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:splitKey: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.LIST, len(p.SplitKey)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.SplitKey {
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:splitKey: %s", p, err)
		}
	}
	return err
}

func (p *MultiHFileSplitKeyRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultiHFileSplitKeyRequest(%+v)", *p)
}

type KeyToValuesResponse struct {
	Values map[string][][]byte `thrift:"values,1" json:"values"`
}

func NewKeyToValuesResponse() *KeyToValuesResponse {
	return &KeyToValuesResponse{}
}

var KeyToValuesResponse_Values_DEFAULT map[string][][]byte

func (p *KeyToValuesResponse) GetValues() map[string][][]byte {
	return p.Values
}
func (p *KeyToValuesResponse) IsSetValues() bool {
	return p.Values != nil
}

func (p *KeyToValuesResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyToValuesResponse) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string][][]byte, size)
	p.Values = tMap
	for i := 0; i < size; i++ {
		var _key14 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key14 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list begin: %s", err)
		}
		tSlice := make([][]byte, 0, size)
		_val15 := tSlice
		for i := 0; i < size; i++ {
			var _elem16 []byte
			if v, err := iprot.ReadBinary(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_elem16 = v
			}
			_val15 = append(_val15, _elem16)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s", err)
		}
		p.Values[_key14] = _val15
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *KeyToValuesResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyToValuesResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyToValuesResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetValues() {
		if err := oprot.WriteFieldBegin("values", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:values: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Values)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Values {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s", err)
			}
			for _, v := range v {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:values: %s", p, err)
		}
	}
	return err
}

func (p *KeyToValuesResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyToValuesResponse(%+v)", *p)
}

type KeyValueItem struct {
	Key   []byte `thrift:"key,1" json:"key"`
	Value []byte `thrift:"value,2" json:"value"`
}

func NewKeyValueItem() *KeyValueItem {
	return &KeyValueItem{}
}

var KeyValueItem_Key_DEFAULT []byte

func (p *KeyValueItem) GetKey() []byte {
	return p.Key
}

var KeyValueItem_Value_DEFAULT []byte

func (p *KeyValueItem) GetValue() []byte {
	return p.Value
}
func (p *KeyValueItem) IsSetKey() bool {
	return p.Key != nil
}

func (p *KeyValueItem) IsSetValue() bool {
	return p.Value != nil
}

func (p *KeyValueItem) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyValueItem) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeyValueItem) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *KeyValueItem) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyValueItem"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyValueItem) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetKey() {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeyValueItem) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetValue() {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:value: %s", p, err)
		}
	}
	return err
}

func (p *KeyValueItem) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyValueItem(%+v)", *p)
}

type IteratorRequest struct {
	HfileName     *string `thrift:"hfileName,1" json:"hfileName"`
	IncludeValues *bool   `thrift:"includeValues,2" json:"includeValues"`
	LastKey       []byte  `thrift:"lastKey,3" json:"lastKey"`
	SkipKeys      *int32  `thrift:"skipKeys,4" json:"skipKeys"`
	ResponseLimit *int32  `thrift:"responseLimit,5" json:"responseLimit"`
	EndKey        []byte  `thrift:"endKey,6" json:"endKey"`
}

func NewIteratorRequest() *IteratorRequest {
	return &IteratorRequest{}
}

var IteratorRequest_HfileName_DEFAULT string

func (p *IteratorRequest) GetHfileName() string {
	if !p.IsSetHfileName() {
		return IteratorRequest_HfileName_DEFAULT
	}
	return *p.HfileName
}

var IteratorRequest_IncludeValues_DEFAULT bool

func (p *IteratorRequest) GetIncludeValues() bool {
	if !p.IsSetIncludeValues() {
		return IteratorRequest_IncludeValues_DEFAULT
	}
	return *p.IncludeValues
}

var IteratorRequest_LastKey_DEFAULT []byte

func (p *IteratorRequest) GetLastKey() []byte {
	return p.LastKey
}

var IteratorRequest_SkipKeys_DEFAULT int32

func (p *IteratorRequest) GetSkipKeys() int32 {
	if !p.IsSetSkipKeys() {
		return IteratorRequest_SkipKeys_DEFAULT
	}
	return *p.SkipKeys
}

var IteratorRequest_ResponseLimit_DEFAULT int32

func (p *IteratorRequest) GetResponseLimit() int32 {
	if !p.IsSetResponseLimit() {
		return IteratorRequest_ResponseLimit_DEFAULT
	}
	return *p.ResponseLimit
}

var IteratorRequest_EndKey_DEFAULT []byte

func (p *IteratorRequest) GetEndKey() []byte {
	return p.EndKey
}
func (p *IteratorRequest) IsSetHfileName() bool {
	return p.HfileName != nil
}

func (p *IteratorRequest) IsSetIncludeValues() bool {
	return p.IncludeValues != nil
}

func (p *IteratorRequest) IsSetLastKey() bool {
	return p.LastKey != nil
}

func (p *IteratorRequest) IsSetSkipKeys() bool {
	return p.SkipKeys != nil
}

func (p *IteratorRequest) IsSetResponseLimit() bool {
	return p.ResponseLimit != nil
}

func (p *IteratorRequest) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *IteratorRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IteratorRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.HfileName = &v
	}
	return nil
}

func (p *IteratorRequest) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.IncludeValues = &v
	}
	return nil
}

func (p *IteratorRequest) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.LastKey = v
	}
	return nil
}

func (p *IteratorRequest) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.SkipKeys = &v
	}
	return nil
}

func (p *IteratorRequest) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.ResponseLimit = &v
	}
	return nil
}

func (p *IteratorRequest) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		p.EndKey = v
	}
	return nil
}

func (p *IteratorRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IteratorRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IteratorRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetHfileName() {
		if err := oprot.WriteFieldBegin("hfileName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:hfileName: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.HfileName)); err != nil {
			return fmt.Errorf("%T.hfileName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:hfileName: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIncludeValues() {
		if err := oprot.WriteFieldBegin("includeValues", thrift.BOOL, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:includeValues: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.IncludeValues)); err != nil {
			return fmt.Errorf("%T.includeValues (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:includeValues: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetLastKey() {
		if err := oprot.WriteFieldBegin("lastKey", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:lastKey: %s", p, err)
		}
		if err := oprot.WriteBinary(p.LastKey); err != nil {
			return fmt.Errorf("%T.lastKey (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:lastKey: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetSkipKeys() {
		if err := oprot.WriteFieldBegin("skipKeys", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:skipKeys: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.SkipKeys)); err != nil {
			return fmt.Errorf("%T.skipKeys (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:skipKeys: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetResponseLimit() {
		if err := oprot.WriteFieldBegin("responseLimit", thrift.I32, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:responseLimit: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.ResponseLimit)); err != nil {
			return fmt.Errorf("%T.responseLimit (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:responseLimit: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndKey() {
		if err := oprot.WriteFieldBegin("endKey", thrift.STRING, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:endKey: %s", p, err)
		}
		if err := oprot.WriteBinary(p.EndKey); err != nil {
			return fmt.Errorf("%T.endKey (6) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:endKey: %s", p, err)
		}
	}
	return err
}

func (p *IteratorRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IteratorRequest(%+v)", *p)
}

type IteratorResponse struct {
	Values   []*KeyValueItem `thrift:"values,1" json:"values"`
	LastKey  []byte          `thrift:"lastKey,2" json:"lastKey"`
	SkipKeys *int32          `thrift:"skipKeys,3" json:"skipKeys"`
}

func NewIteratorResponse() *IteratorResponse {
	return &IteratorResponse{}
}

var IteratorResponse_Values_DEFAULT []*KeyValueItem

func (p *IteratorResponse) GetValues() []*KeyValueItem {
	return p.Values
}

var IteratorResponse_LastKey_DEFAULT []byte

func (p *IteratorResponse) GetLastKey() []byte {
	return p.LastKey
}

var IteratorResponse_SkipKeys_DEFAULT int32

func (p *IteratorResponse) GetSkipKeys() int32 {
	if !p.IsSetSkipKeys() {
		return IteratorResponse_SkipKeys_DEFAULT
	}
	return *p.SkipKeys
}
func (p *IteratorResponse) IsSetValues() bool {
	return p.Values != nil
}

func (p *IteratorResponse) IsSetLastKey() bool {
	return p.LastKey != nil
}

func (p *IteratorResponse) IsSetSkipKeys() bool {
	return p.SkipKeys != nil
}

func (p *IteratorResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IteratorResponse) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*KeyValueItem, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		_elem17 := &KeyValueItem{}
		if err := _elem17.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem17, err)
		}
		p.Values = append(p.Values, _elem17)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *IteratorResponse) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.LastKey = v
	}
	return nil
}

func (p *IteratorResponse) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.SkipKeys = &v
	}
	return nil
}

func (p *IteratorResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IteratorResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IteratorResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetValues() {
		if err := oprot.WriteFieldBegin("values", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:values: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Values)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Values {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:values: %s", p, err)
		}
	}
	return err
}

func (p *IteratorResponse) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetLastKey() {
		if err := oprot.WriteFieldBegin("lastKey", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:lastKey: %s", p, err)
		}
		if err := oprot.WriteBinary(p.LastKey); err != nil {
			return fmt.Errorf("%T.lastKey (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:lastKey: %s", p, err)
		}
	}
	return err
}

func (p *IteratorResponse) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetSkipKeys() {
		if err := oprot.WriteFieldBegin("skipKeys", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:skipKeys: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.SkipKeys)); err != nil {
			return fmt.Errorf("%T.skipKeys (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:skipKeys: %s", p, err)
		}
	}
	return err
}

func (p *IteratorResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IteratorResponse(%+v)", *p)
}

type HFileInfo struct {
	Name        *string  `thrift:"name,1" json:"name"`
	Path        *string  `thrift:"path,2" json:"path"`
	NumElements *int64   `thrift:"numElements,3" json:"numElements"`
	FirstKey    []byte   `thrift:"firstKey,4" json:"firstKey"`
	LastKey     []byte   `thrift:"lastKey,5" json:"lastKey"`
	RandomKeys  [][]byte `thrift:"randomKeys,6" json:"randomKeys"`
}

func NewHFileInfo() *HFileInfo {
	return &HFileInfo{}
}

var HFileInfo_Name_DEFAULT string

func (p *HFileInfo) GetName() string {
	if !p.IsSetName() {
		return HFileInfo_Name_DEFAULT
	}
	return *p.Name
}

var HFileInfo_Path_DEFAULT string

func (p *HFileInfo) GetPath() string {
	if !p.IsSetPath() {
		return HFileInfo_Path_DEFAULT
	}
	return *p.Path
}

var HFileInfo_NumElements_DEFAULT int64

func (p *HFileInfo) GetNumElements() int64 {
	if !p.IsSetNumElements() {
		return HFileInfo_NumElements_DEFAULT
	}
	return *p.NumElements
}

var HFileInfo_FirstKey_DEFAULT []byte

func (p *HFileInfo) GetFirstKey() []byte {
	return p.FirstKey
}

var HFileInfo_LastKey_DEFAULT []byte

func (p *HFileInfo) GetLastKey() []byte {
	return p.LastKey
}

var HFileInfo_RandomKeys_DEFAULT [][]byte

func (p *HFileInfo) GetRandomKeys() [][]byte {
	return p.RandomKeys
}
func (p *HFileInfo) IsSetName() bool {
	return p.Name != nil
}

func (p *HFileInfo) IsSetPath() bool {
	return p.Path != nil
}

func (p *HFileInfo) IsSetNumElements() bool {
	return p.NumElements != nil
}

func (p *HFileInfo) IsSetFirstKey() bool {
	return p.FirstKey != nil
}

func (p *HFileInfo) IsSetLastKey() bool {
	return p.LastKey != nil
}

func (p *HFileInfo) IsSetRandomKeys() bool {
	return p.RandomKeys != nil
}

func (p *HFileInfo) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *HFileInfo) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Name = &v
	}
	return nil
}

func (p *HFileInfo) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Path = &v
	}
	return nil
}

func (p *HFileInfo) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.NumElements = &v
	}
	return nil
}

func (p *HFileInfo) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.FirstKey = v
	}
	return nil
}

func (p *HFileInfo) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.LastKey = v
	}
	return nil
}

func (p *HFileInfo) ReadField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.RandomKeys = tSlice
	for i := 0; i < size; i++ {
		var _elem18 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem18 = v
		}
		p.RandomKeys = append(p.RandomKeys, _elem18)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *HFileInfo) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("HFileInfo"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *HFileInfo) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetName() {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Name)); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetPath() {
		if err := oprot.WriteFieldBegin("path", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:path: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Path)); err != nil {
			return fmt.Errorf("%T.path (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:path: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNumElements() {
		if err := oprot.WriteFieldBegin("numElements", thrift.I64, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:numElements: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.NumElements)); err != nil {
			return fmt.Errorf("%T.numElements (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:numElements: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetFirstKey() {
		if err := oprot.WriteFieldBegin("firstKey", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:firstKey: %s", p, err)
		}
		if err := oprot.WriteBinary(p.FirstKey); err != nil {
			return fmt.Errorf("%T.firstKey (4) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:firstKey: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetLastKey() {
		if err := oprot.WriteFieldBegin("lastKey", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:lastKey: %s", p, err)
		}
		if err := oprot.WriteBinary(p.LastKey); err != nil {
			return fmt.Errorf("%T.lastKey (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:lastKey: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetRandomKeys() {
		if err := oprot.WriteFieldBegin("randomKeys", thrift.LIST, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:randomKeys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.RandomKeys)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.RandomKeys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:randomKeys: %s", p, err)
		}
	}
	return err
}

func (p *HFileInfo) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("HFileInfo(%+v)", *p)
}

type InfoRequest struct {
	HfileName     *string `thrift:"hfileName,1" json:"hfileName"`
	NumRandomKeys *int64  `thrift:"numRandomKeys,2" json:"numRandomKeys"`
}

func NewInfoRequest() *InfoRequest {
	return &InfoRequest{}
}

var InfoRequest_HfileName_DEFAULT string

func (p *InfoRequest) GetHfileName() string {
	if !p.IsSetHfileName() {
		return InfoRequest_HfileName_DEFAULT
	}
	return *p.HfileName
}

var InfoRequest_NumRandomKeys_DEFAULT int64

func (p *InfoRequest) GetNumRandomKeys() int64 {
	if !p.IsSetNumRandomKeys() {
		return InfoRequest_NumRandomKeys_DEFAULT
	}
	return *p.NumRandomKeys
}
func (p *InfoRequest) IsSetHfileName() bool {
	return p.HfileName != nil
}

func (p *InfoRequest) IsSetNumRandomKeys() bool {
	return p.NumRandomKeys != nil
}

func (p *InfoRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InfoRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.HfileName = &v
	}
	return nil
}

func (p *InfoRequest) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NumRandomKeys = &v
	}
	return nil
}

func (p *InfoRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InfoRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *InfoRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetHfileName() {
		if err := oprot.WriteFieldBegin("hfileName", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:hfileName: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.HfileName)); err != nil {
			return fmt.Errorf("%T.hfileName (1) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:hfileName: %s", p, err)
		}
	}
	return err
}

func (p *InfoRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetNumRandomKeys() {
		if err := oprot.WriteFieldBegin("numRandomKeys", thrift.I64, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:numRandomKeys: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.NumRandomKeys)); err != nil {
			return fmt.Errorf("%T.numRandomKeys (2) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:numRandomKeys: %s", p, err)
		}
	}
	return err
}

func (p *InfoRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InfoRequest(%+v)", *p)
}
